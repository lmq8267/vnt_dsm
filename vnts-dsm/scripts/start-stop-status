#!/bin/sh

# 默认显示名称
DNAME="${SYNOPKG_PKGNAME}"
VNTS_config="${SYNOPKG_PKGVAR}/config.yaml"
LOG_FILE="${SYNOPKG_PKGVAR}/${SYNOPKG_PKGNAME}.log"

if [ "$SYNOPKG_DSM_VERSION_MAJOR" -lt 7 ]; then
    # 为了向前兼容，定义 SYNOPKG_PKGVAR。
    SYNOPKG_PKGVAR="${SYNOPKG_PKGDEST}/var"
fi

# 源软件包特定的变量和函数
SVC_SETUP=$(dirname $0)"/service-setup"
if [ -r "${SVC_SETUP}" ]; then
    . "${SVC_SETUP}"
fi

log_msg() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')]: INFO $1" >> ${LOG_FILE}
}

# 如果可用，则调用 shell 函数。
call_func ()
{
    FUNC=$1
    if type "${FUNC}" 2>/dev/null | grep -q 'function' 2>/dev/null; then
        log_msg "${FUNC} 开始" >> ${LOG_FILE}
        eval ${FUNC} >> ${LOG_FILE}
        log_msg "${FUNC} 结束" >> ${LOG_FILE}
    fi
}

start_daemon ()
{
	VNTS_CMD=$(cat /var/packages/VNTS/var/vnts.cmd | tr -d '\n')
	service="./vnts ${VNTS_CMD}"
	
            if [ -n "${USER}" -a -n "${SYNOPKG_DSM_VERSION_MAJOR}" -a "$SYNOPKG_DSM_VERSION_MAJOR" -lt 6 ]; then
                if [ -z "${SVC_CWD}" ]; then
                    SVC_CD=""
                else
                    SVC_CD="cd ${SVC_CWD} ; "
                fi
                if [ -n "${SYNOPKG_DSM_VERSION_MAJOR}" ] && [ "${SYNOPKG_DSM_VERSION_MAJOR}" -lt 7 ]; then
                    SU="su ${EFF_USER} -s"
                else
                    SU=""
                fi
                log_msg "启动参数： ${SVC_CD}${service}" >> ${LOG_FILE}
                if [ -z "${SVC_BACKGROUND}" ]; then
                    $SU /bin/sh -c "${SVC_CD}${service}" >> ${LOG_FILE} 2>&1
                else
                    $SU /bin/sh -c "${SVC_CD}${service}" >> ${LOG_FILE}2>&1 &
                fi

            else
                # DSM 6 用户权限由 conf/privilege 文件设置
                if [ -n "${SVC_CWD}" ]; then
                    cd "${SVC_CWD}"
                    vcwd="cd ${SVC_CWD} ; "
                fi
                log_msg "启动参数： ${vcwd}${service}" >> ${LOG_FILE}
                if [ -z "${SVC_BACKGROUND}" ]; then
                    ${service} >> ${LOG_FILE} 2>&1
                else
                    ${service} >> ${LOG_FILE} 2>&1 &
                fi
            fi
            if [ -n "${SVC_WRITE_PID}" -a -n "${SVC_BACKGROUND}" -a -n "${PID_FILE}" ]; then
                [ $i -eq 1 ] && echo -ne "$!" > ${PID_FILE} || echo -ne " $!" >> ${PID_FILE}
            else
                wait_for_status 0 ${SVC_WAIT_TIMEOUT:=20}
            fi
    # 记录运行时间
    echo `date +%s` > /var/packages/VNTS/var/vnts_time
}

stop_daemon ()
{
    if [ -n "${PID_FILE}" -a -r "${PID_FILE}" ]; then
        for pid in $(cat "${PID_FILE}")
        do
            log_msg "正在停止 ${DNAME} 服务，进程ID : $(ps -p${pid} -o comm=) (${pid})" >> ${LOG_FILE}
            kill -TERM ${pid} >> ${LOG_FILE} 2>&1
            wait_for_status 1 ${SVC_WAIT_TIMEOUT:=20} ${pid} || kill -KILL ${pid} >> ${LOG_FILE} 2>&1
        done
        if [ -f "${PID_FILE}" ]; then
            rm -f "${PID_FILE}" > /dev/null
        fi
    fi
    killall vnts 2>/dev/null
    
    call_func "service_poststop"
}

#------------------------------------------------------
# daemon_status()
# 守护进程状态 $1：要检查的进程ID，如果为空则使用 ${PID_FILE}
# 状态：跟踪 kill -0 命令的退出状态。
#
# 如果所有进程ID都正常，则返回 0；否则返回 1。
#------------------------------------------------------
daemon_status ()
{
    status=0
    [ -z "${1}" ] && pid_list=$(cat ${PID_FILE} 2>/dev/null) || pid_list=${1}
    if [ -n "${pid_list}" ]; then
        for pid in ${pid_list}
        do
           kill -0 ${pid} > /dev/null 2>&1
           let status=$status+$?
        done
        if [ $status -ne 0 ]; then
           rm -f "${PID_FILE}" > /dev/null
           return 1
        else
           return 0
        fi
    else
        return 1
    fi
}

#------------------------------------------------------
# wait_for_status()
# 等待状态 $1：调用 daemon_status() 函数的预期返回值
#      $2：超时时间（例如，需要执行的循环次数）
#      $3：要检查的进程ID被传递给 daemon_status() 函数。
# 计数器：等待的1秒迭代次数
#          daemon_status() 函数的返回值
#          匹配预期值
#
# 请等待 $counter 秒钟
# 返回 daemon_status() 的返回值。如果匹配，则...
# 如果等待时间结束，则返回 0，否则返回 1
#------------------------------------------------------
wait_for_status ()
{
    # 默认值：20秒
    counter=${2}
    counter=${counter:=20}
    while [ ${counter} -gt 0 ]; do
        daemon_status ${3}
        [ $? -eq $1 ] && return
        let counter=counter-1
        sleep 1
    done
    return 1
}

# 启动命令监控循环  
start_command_monitor()  
{  
    # 创建命令文件  
    COMMAND_FILE="/var/packages/VNTS/var/start-stop"  
    touch "$COMMAND_FILE"  
      
    # 在后台启动监控循环  
    (  
        while true; do  
            if [ -f "$COMMAND_FILE" ]; then  
                COMMAND=$(cat "$COMMAND_FILE" 2>/dev/null | tr -d ' \t\n\r')
                if [ -n "$COMMAND" ]; then
                    case "$COMMAND" in
                        "start")
                            if ! daemon_status; then
                                log_msg "用户手动触发启动服务" > ${LOG_FILE}
                                start_daemon
                            fi
                            ;;
                        "stop")
                            if daemon_status; then
                                log_msg "用户手动触发停止服务" > ${LOG_FILE}
                                stop_daemon
                            fi
                            ;;
                        "restart")
                            log_msg "用户修改了参数，重启服务" > ${LOG_FILE}
                            if daemon_status; then
                                stop_daemon
                            fi
                            sleep 2
                            start_daemon
                            ;;
                    esac
                    # 处理完成后清空命令文件  
                    > "$COMMAND_FILE"  
                fi  
            fi  
            sleep 1  
        done  
    ) &  
      
    # 保存监控进程PID用于清理  
    echo $! > /var/packages/VNTS/var/monitor.pid  
}

start_log_cleaner() {
      
    (  
        while true; do  
            if [ -f "$LOG_FILE" ] && [ $(wc -l < "$LOG_FILE" 2>/dev/null) -gt 1000 ]; then
                tail -n 1000 "$LOG_FILE" > "${LOG_FILE}.tmp"
                mv "${LOG_FILE}.tmp" "$LOG_FILE"
                log_msg "日志文件已清理，保留最后1000行"
            fi  
            sleep 300
        done
    ) &
      
    echo $! > /var/packages/VNTS/var/logcleaner.pid
}

case $1 in
    start)
        if [ "${SYNOPKG_PKGNAME}" != "VNTS" ]; then
              exit 1
        fi
        if daemon_status; then
            exit 0
        else
            # 清空日志
    	     > "${LOG_FILE}"
            log_msg "开始运行 ${DNAME} 套件 ..." >> ${LOG_FILE}
            [ -d /var/packages/VNTS/var/vnts_wg ] || mkdir -p /var/packages/VNTS/var/vnts_wg
            [ -L /var/packages/VNTS/target/bin/vnts_wg ] || ln -sf /var/packages/VNTS/var/vnts_wg /var/packages/VNTS/target/bin/vnts_wg
            [ -d /var/packages/VNTS/var/key ] || mkdir -p /var/packages/VNTS/var/key
            [ -L /var/packages/VNTS/target/bin/key ] || ln -sf /var/packages/VNTS/var/key /var/packages/VNTS/target/bin/key
            # 启动命令监控  
            start_command_monitor
            start_log_cleaner
            start_daemon
            exit $?
        fi
        ;;
    stop)
    	# 停止命令监控进程  
    	MONITOR_PID_FILE="/var/packages/VNTS/var/monitor.pid"  
    	if [ -f "$MONITOR_PID_FILE" ]; then  
        	MONITOR_PID=$(cat "$MONITOR_PID_FILE")  
        	if [ -n "$MONITOR_PID" ] && kill -0 $MONITOR_PID 2>/dev/null; then  
            		# log_msg "停止命令监控进程 ${MONITOR_PID}" >> ${LOG_FILE}  
            		kill -TERM $MONITOR_PID >> ${LOG_FILE} 2>&1  
        	fi  
        	rm -f "$MONITOR_PID_FILE"  
    	fi
    	# 停止日志清理进程
	LOGCLEANER_PID_FILE="/var/packages/VNTS/var/logcleaner.pid"
	if [ -f "$LOGCLEANER_PID_FILE" ]; then
    	LOGCLEANER_PID=$(cat "$LOGCLEANER_PID_FILE")
    	if [ -n "$LOGCLEANER_PID" ] && kill -0 $LOGCLEANER_PID 2>/dev/null; then
        	kill -TERM $LOGCLEANER_PID >> ${LOG_FILE} 2>&1
    	fi
    		rm -f "$LOGCLEANER_PID_FILE"
	fi
        if daemon_status; then
            log_msg "正在停止 ${DNAME} 套件 ..." >> ${LOG_FILE}
            stop_daemon
            exit $?
        else
            exit 0
        fi
        ;;
    status)
        if daemon_status; then
            echo "${DNAME} 运行中"
            exit 0
        else
            echo "${DNAME} 未运行"
            exit 0
        fi
        ;;
    log)
        # DSM < 6 的日志输出
        if [ -n "${LOG_FILE}" -a -r "${LOG_FILE}" ]; then
            # 将长日志文件截短，只保留最后100行。
            TEMP_LOG_FILE="${SYNOPKG_PKGVAR}/${SYNOPKG_PKGNAME}_temp.log"
            # 清除所有之前的日志。
            echo "完整日志: ${LOG_FILE}" > "${TEMP_LOG_FILE}"
            tail -n100 "${LOG_FILE}" >> "${TEMP_LOG_FILE}"
            echo "${TEMP_LOG_FILE}"
        fi
        exit 0
        ;;
    *)
        exit 1
        ;;
esac

